# 渠道额外设置

<cite>
**本文档引用文件**   
- [channel_settings.go](file://dto/channel_settings.go)
- [channel.go](file://model/channel.go)
- [EditChannelModal.jsx](file://web/src/components/table/channels/modals/EditChannelModal.jsx)
- [other_setting.md](file://docs/channel/other_setting.md)
- [relay-openai.go](file://relay/channel/openai/relay-openai.go)
- [adaptor.go](file://relay/channel/openai/adaptor.go)
- [http_client.go](file://service/http_client.go)
- [video_proxy.go](file://controller/video_proxy.go)
</cite>

## 目录
1. [简介](#简介)
2. [核心设置项](#核心设置项)
3. [配置存储与解析](#配置存储与解析)
4. [代理设置实现](#代理设置实现)
5. [强制格式化机制](#强制格式化机制)
6. [思考内容转换](#思考内容转换)
7. [完整配置示例](#完整配置示例)
8. [API请求处理流程](#api请求处理流程)

## 简介
渠道额外设置功能允许用户通过JSON格式的配置来定义渠道的高级行为。这些设置存储在渠道的`Setting`字段中，通过`ChannelSettings`结构体进行解析和管理。主要功能包括代理配置、强制格式化和思考内容转换，这些设置直接影响API请求的处理流程和响应格式。

## 核心设置项
渠道额外设置包含以下核心配置项：

- **force_format**: 布尔值，标识是否强制将响应格式化为OpenAI标准格式
- **thinking_to_content**: 布尔值，标识是否将思考内容`reasoning_content`转换为`<think>`标签拼接到内容中返回
- **proxy**: 字符串，用于配置网络代理地址（例如socks5协议的代理地址）
- **pass_through_body_enabled**: 布尔值，标识是否启用请求体透传功能
- **system_prompt**: 字符串，用于设置系统提示词
- **system_prompt_override**: 布尔值，标识是否将系统提示词拼接到用户的系统提示词前面

**Section sources**
- [channel_settings.go](file://dto/channel_settings.go#L3-L9)
- [EditChannelModal.jsx](file://web/src/components/table/channels/modals/EditChannelModal.jsx#L2922-L2951)

## 配置存储与解析
渠道额外设置通过`Channel`结构体的`Setting`字段进行存储，该字段为可空字符串类型，存储JSON格式的配置数据。

```mermaid
classDiagram
class Channel {
+Id int
+Type int
+Key string
+Status int
+Name string
+Setting *string
+GetSetting() ChannelSettings
+SetSetting(setting ChannelSettings)
+ValidateSettings() error
}
class ChannelSettings {
+ForceFormat bool
+ThinkingToContent bool
+Proxy string
+PassThroughBodyEnabled bool
+SystemPrompt string
+SystemPromptOverride bool
}
Channel --> ChannelSettings : "序列化/反序列化"
```

**Diagram sources**
- [channel.go](file://model/channel.go#L47)
- [channel_settings.go](file://dto/channel_settings.go#L3-L9)

当获取渠道设置时，系统会调用`GetSetting()`方法，该方法将JSON字符串反序列化为`ChannelSettings`结构体。如果反序列化失败，系统会记录错误日志并清空设置以避免后续错误。

```mermaid
flowchart TD
Start([获取渠道设置]) --> CheckSetting["检查Setting字段是否为空"]
CheckSetting --> |为空| ReturnDefault["返回默认设置值"]
CheckSetting --> |不为空| Unmarshal["反序列化JSON字符串"]
Unmarshal --> |成功| ReturnResult["返回解析后的设置"]
Unmarshal --> |失败| LogError["记录系统日志并清空设置"]
LogError --> ReturnDefault
```

**Diagram sources**
- [channel.go](file://model/channel.go#L852-L863)

## 代理设置实现
代理设置通过`proxy`字段配置，支持HTTP/HTTPS和SOCKS5/socks5h协议。系统在处理需要代理的请求时，会根据配置创建相应的HTTP客户端。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Service as "服务层"
participant Proxy as "代理服务器"
participant Target as "目标API"
Client->>Service : 发起API请求
Service->>Service : 获取渠道设置
Service->>Service : 检查代理配置
alt 代理已配置
Service->>Service : 创建代理HTTP客户端
Service->>Proxy : 通过代理发送请求
Proxy->>Target : 转发请求
Target-->>Proxy : 返回响应
Proxy-->>Service : 转发响应
else 无代理配置
Service->>Target : 直接发送请求
Target-->>Service : 返回响应
end
Service-->>Client : 返回处理后的响应
```

**Diagram sources**
- [http_client.go](file://service/http_client.go#L61-L156)
- [video_proxy.go](file://controller/video_proxy.go#L80-L81)

代理客户端的创建由`NewProxyHttpClient`函数实现，该函数根据代理URL的协议类型创建相应的传输层：

- **HTTP/HTTPS代理**: 使用`http.Transport`的`Proxy`字段直接配置
- **SOCKS5代理**: 使用`golang.org/x/net/proxy`库创建SOCKS5拨号器，通过`DialContext`自定义连接

系统还实现了代理客户端缓存机制，相同代理URL的客户端会被缓存以提高性能，并提供`ResetProxyClientCache`函数用于清空缓存。

**Section sources**
- [http_client.go](file://service/http_client.go#L81-L156)

## 强制格式化机制
强制格式化功能通过`force_format`设置项控制，当启用时，系统会确保响应符合OpenAI标准格式。

```mermaid
flowchart TD
Start([API响应处理]) --> CheckForceFormat["检查force_format设置"]
CheckForceFormat --> |启用| ApplyFormatting["应用格式化规则"]
ApplyFormatting --> ValidateUsage["验证Usage字段"]
ValidateUsage --> |PromptTokens为0| CalculateTokens["计算提示词Token"]
CalculateTokens --> UpdateUsage["更新Usage字段"]
UpdateUsage --> ApplyPostProcessing["应用使用量后处理"]
ApplyPostProcessing --> ReturnResponse["返回格式化响应"]
CheckForceFormat --> |禁用| ReturnOriginal["返回原始响应"]
```

**Diagram sources**
- [relay-openai.go](file://relay/channel/openai/relay-openai.go#L232-L254)

当`force_format`启用且响应中的`PromptTokens`为0时，系统会根据估算的提示词Token数和完成内容Token数重新计算使用量：

```go
if simpleResponse.Usage.PromptTokens == 0 {
    completionTokens := simpleResponse.Usage.CompletionTokens
    if completionTokens == 0 {
        for _, choice := range simpleResponse.Choices {
            ctkm := service.CountTextToken(choice.Message.StringContent()+choice.Message.ReasoningContent+choice.Message.Reasoning, info.UpstreamModelName)
            completionTokens += ctkm
        }
    }
    simpleResponse.Usage = dto.Usage{
        PromptTokens:     info.GetEstimatePromptTokens(),
        CompletionTokens: completionTokens,
        TotalTokens:      info.GetEstimatePromptTokens() + completionTokens,
    }
    usageModified = true
}
```

**Section sources**
- [relay-openai.go](file://relay/channel/openai/relay-openai.go#L237-L251)

## 思考内容转换
思考内容转换功能通过`thinking_to_content`设置项控制，当启用时，系统会将`reasoning_content`转换为`<think>`标签拼接到内容中返回。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Relay as "中继服务"
participant Upstream as "上游API"
Client->>Relay : 发起流式请求
Relay->>Upstream : 转发请求
Upstream->>Relay : 返回包含reasoning_content的流式响应
alt thinking_to_content启用
Relay->>Relay : 检测到首次thinking_content
Relay->>Client : 发送"<think>\n" + thinking_content
Relay->>Relay : 标记已发送thinking_content
Relay->>Relay : 检测到内容转换
Relay->>Client : 发送"\n</think>\n"
else thinking_to_content禁用
Relay->>Client : 直接转发原始响应
end
Relay->>Client : 继续流式响应
```

**Diagram sources**
- [adaptor.go](file://relay/channel/openai/adaptor.go#L97-L107)
- [relay-openai.go](file://relay/channel/openai/relay-openai.go#L56-L89)

在`Adaptor`的`Init`方法中，当`thinking_to_content`启用时，会初始化`ThinkingContentInfo`状态：

```go
if info.ChannelSetting.ThinkingToContent {
    info.ThinkingContentInfo = relaycommon.ThinkingContentInfo{
        IsFirstThinkingContent:  true,
        SendLastThinkingContent: false,
        HasSentThinkingContent:  false,
    }
}
```

在流式响应处理中，系统会检测`reasoning_content`并将其转换为`<think>`标签：

```go
if info.ThinkingContentInfo.IsFirstThinkingContent {
    if hasThinkingContent {
        response := lastStreamResponse.Copy()
        for i := range response.Choices {
            response.Choices[i].Delta.SetContentString("<think>\\n" + thinkingContent.String())
            response.Choices[i].Delta.ReasoningContent = nil
            response.Choices[i].Delta.Reasoning = nil
        }
        info.ThinkingContentInfo.IsFirstThinkingContent = false
        info.ThinkingContentInfo.HasSentThinkingContent = true
        return helper.ObjectData(c, response)
    }
}
```

**Section sources**
- [adaptor.go](file://relay/channel/openai/adaptor.go#L101-L107)
- [relay-openai.go](file://relay/channel/openai/relay-openai.go#L56-L68)

## 完整配置示例
以下是一个完整的渠道额外设置配置示例：

```json
{
    "force_format": true,
    "thinking_to_content": true,
    "proxy": "socks5://username:password@proxy.example.com:1080",
    "pass_through_body_enabled": false,
    "system_prompt": "你是一个有帮助的AI助手。",
    "system_prompt_override": true
}
```

此配置启用了强制格式化和思考内容转换，配置了SOCKS5代理，并设置了系统提示词。当用户请求中包含系统提示词时，会将此设置的提示词拼接到用户提示词前面。

**Section sources**
- [other_setting.md](file://docs/channel/other_setting.md#L23-L29)

## API请求处理流程
渠道额外设置在API请求处理流程中扮演重要角色，影响从请求接收、代理配置到响应格式化的各个环节。

```mermaid
flowchart TD
A([接收API请求]) --> B{路由到渠道}
B --> C[获取渠道信息]
C --> D[解析渠道设置]
D --> E{检查代理设置}
E --> |已配置| F[创建代理HTTP客户端]
E --> |未配置| G[使用默认HTTP客户端]
F --> H
G --> H
H[转发请求到上游API] --> I[接收上游响应]
I --> J{检查强制格式化}
J --> |启用| K[格式化响应为OpenAI标准]
J --> |禁用| L[保持原始响应格式]
K --> M
L --> M
M --> N{检查思考内容转换}
N --> |启用| O[转换reasoning_content为<think>标签]
N --> |禁用| P[保持原始内容]
O --> Q[返回处理后的响应]
P --> Q
Q --> R([客户端收到响应])
```

**Diagram sources**
- [channel.go](file://model/channel.go#L852-L863)
- [http_client.go](file://service/http_client.go#L61-L156)
- [relay-openai.go](file://relay/channel/openai/relay-openai.go#L232-L254)
- [adaptor.go](file://relay/channel/openai/adaptor.go#L97-L107)

整个处理流程确保了渠道额外设置能够正确影响API请求的各个方面，从网络穿透到响应格式，为用户提供灵活的配置选项。

**Section sources**
- [channel.go](file://model/channel.go#L852-L863)
- [http_client.go](file://service/http_client.go#L61-L156)
- [relay-openai.go](file://relay/channel/openai/relay-openai.go#L232-L254)
- [adaptor.go](file://relay/channel/openai/adaptor.go#L97-L107)