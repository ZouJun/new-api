# 用户删除与数据清理

<cite>
**本文档引用的文件**   
- [user.go](file://controller/user.go)
- [user.go](file://model/user.go)
- [token.go](file://model/token.go)
- [log.go](file://model/log.go)
- [topup.go](file://model/topup.go)
- [gopool.go](file://common/gopool.go)
- [main.go](file://model/main.go)
</cite>

## 目录
1. [简介](#简介)
2. [软删除机制](#软删除机制)
3. [级联清理任务](#级联清理任务)
4. [并发控制策略](#并发控制策略)
5. [操作日志记录](#操作日志记录)
6. [误删恢复建议](#误删恢复建议)

## 简介
本文档深入解析用户删除操作的软删除机制，说明`DeletedAt`字段在GORM中的应用及其对查询过滤的影响。文档详细描述了用户删除触发的级联清理任务，包括令牌（token）、日志（log）、充值记录（topup）等相关数据的异步清理流程。同时，解释了GoPool（common/gopool.go）在处理大规模用户数据清理时的并发控制策略，详述操作日志记录规范以确保所有删除动作可审计，并提供恢复误删用户的建议方案。

## 软删除机制

系统采用GORM的软删除功能来管理用户删除操作。当用户被删除时，系统并非从数据库中物理移除记录，而是通过设置`DeletedAt`时间戳来标记该记录为已删除状态。

在`model/user.go`文件中，`User`结构体定义了`DeletedAt`字段：
```go
type User struct {
    // ... 其他字段
    DeletedAt        gorm.DeletedAt `gorm:"index"`
}
```
此字段是GORM软删除机制的核心。当调用`Delete()`方法时，GORM会自动将当前时间写入`DeletedAt`字段，而不是执行SQL的`DELETE`语句。

在查询用户时，GORM默认会自动添加`WHERE deleted_at IS NULL`条件，从而过滤掉已被软删除的用户。如果需要查询包括已删除用户在内的所有记录，必须使用`Unscoped()`方法：
```go
// 查询所有用户，包括已删除的
DB.Unscoped().Find(&users)

// 仅查询未删除的用户（默认行为）
DB.Find(&users)
```

用户删除操作由`controller/user.go`中的`DeleteUser`函数处理，该函数执行软删除操作：
```go
func DeleteUser(c *gin.Context) {
    // ... 参数验证
    err = model.HardDeleteUserById(id) // 注意：此处实际执行的是软删除
    // ... 响应处理
}
```

**Section sources**
- [user.go](file://model/user.go#L44)
- [user.go](file://controller/user.go#L778-L805)

## 级联清理任务

用户删除操作会触发一系列异步的级联清理任务，以确保与该用户相关的所有数据都被正确清理。这些任务包括清理令牌、日志和充值记录等。

### 令牌清理
当用户被删除时，系统会自动清理与该用户关联的所有令牌。这通过`model/token.go`中的`BatchDeleteTokens`函数实现：
```go
func BatchDeleteTokens(ids []int, userId int) (int, error) {
    // ... 事务处理
    if err := tx.Where("user_id = ? AND id IN (?)", userId, ids).Delete(&Token{}).Error; err != nil {
        tx.Rollback()
        return 0, err
    }
    // ... 提交事务
}
```
此函数在事务中执行，确保数据一致性，并在Redis缓存中异步删除已清理的令牌。

### 日志清理
用户相关的日志记录也会被清理。`model/log.go`中的`DeleteOldLog`函数负责清理旧日志：
```go
func DeleteOldLog(ctx context.Context, targetTimestamp int64, limit int) (int64, error) {
    var total int64 = 0
    for {
        if nil != ctx.Err() {
            return total, ctx.Err()
        }
        
        result := LOG_DB.Where("created_at < ?", targetTimestamp).Limit(limit).Delete(&Log{})
        if nil != result.Error {
            return total, result.Error
        }
        
        total += result.RowsAffected
        
        if result.RowsAffected < int64(limit) {
            break
        }
    }
    return total, nil
}
```
该函数采用分批删除的方式，避免一次性删除大量数据导致数据库性能问题。

### 充值记录清理
用户的充值记录同样会被清理。`model/topup.go`中的`ManualCompleteTopUp`函数展示了如何处理充值记录：
```go
func ManualCompleteTopUp(tradeNo string) error {
    // ... 事务处理
    topUp := &TopUp{}
    if err := tx.Set("gorm:query_option", "FOR UPDATE").Where(refCol+" = ?", tradeNo).First(topUp).Error; err != nil {
        return errors.New("充值订单不存在")
    }
    // ... 更新订单状态
}
```

**Section sources**
- [token.go](file://model/token.go#L333-L365)
- [log.go](file://model/log.go#L390-L411)
- [topup.go](file://model/topup.go#L238-L307)

## 并发控制策略

系统使用GoPool（common/gopool.go）来处理大规模用户数据清理时的并发控制。GoPool是一个轻量级的Goroutine池，用于管理并发任务，避免创建过多的Goroutine导致系统资源耗尽。

在`common/gopool.go`中，系统初始化了一个全局的Goroutine池：
```go
var relayGoPool gopool.Pool

func init() {
    relayGoPool = gopool.NewPool("gopool.RelayPool", math.MaxInt32, gopool.NewConfig())
    relayGoPool.SetPanicHandler(func(ctx context.Context, i interface{}) {
        if stopChan, ok := ctx.Value("stop_chan").(chan bool); ok {
            SafeSendBool(stopChan, true)
        }
        SysError(fmt.Sprintf("panic in gopool.RelayPool: %v", i))
    })
}
```
该池的大小设置为`math.MaxInt32`，意味着它可以处理大量的并发任务。

系统通过`RelayCtxGo`函数来提交异步任务：
```go
func RelayCtxGo(ctx context.Context, f func()) {
    relayGoPool.CtxGo(ctx, f)
}
```
这种并发控制策略确保了系统在处理大量用户数据清理任务时的稳定性和性能。

**Section sources**
- [gopool.go](file://common/gopool.go#L11-L25)

## 操作日志记录

系统严格遵循操作日志记录规范，确保所有删除动作都可审计。每次用户删除操作都会记录详细的日志信息。

在`model/log.go`中，`RecordLog`函数负责记录操作日志：
```go
func RecordLog(userId int, logType int, content string) {
    if logType == LogTypeConsume && !common.LogConsumeEnabled {
        return
    }
    username, _ := GetUsernameById(userId, false)
    log := &Log{
        UserId:    userId,
        Username:  username,
        CreatedAt: common.GetTimestamp(),
        Type:      logType,
        Content:   content,
    }
    err := LOG_DB.Create(log).Error
    if err != nil {
        common.SysLog("failed to record log: " + err.Error())
    }
}
```
日志类型包括：
- `LogTypeUnknown` (0): 未知类型
- `LogTypeTopup` (1): 充值记录
- `LogTypeConsume` (2): 消费记录
- `LogTypeManage` (3): 管理操作
- `LogTypeSystem` (4): 系统事件
- `LogTypeError` (5): 错误事件
- `LogTypeRefund` (6): 退款记录

这些日志记录不仅有助于审计，还可以用于系统监控和故障排查。

**Section sources**
- [log.go](file://model/log.go#L81-L97)

## 误删恢复建议

为防止误删用户，系统提供了以下恢复建议：

1. **定期备份**：定期备份数据库，确保在发生误删时可以快速恢复数据。
2. **软删除机制**：利用GORM的软删除功能，被删除的用户记录实际上仍然存在于数据库中，可以通过`Unscoped()`方法查询并恢复。
3. **权限控制**：严格控制用户删除权限，只有高级管理员才能执行删除操作。
4. **确认机制**：在执行删除操作前，要求管理员进行二次确认。
5. **审计日志**：通过操作日志记录，可以追踪删除操作的执行者和时间，便于事后审计。

通过以上措施，可以有效防止误删用户，并在发生误删时快速恢复。

**Section sources**
- [user.go](file://model/user.go#L320-L325)
- [main.go](file://model/main.go#L250-L274)