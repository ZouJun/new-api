# 认证机制

<cite>
**本文档引用的文件**   
- [auth.go](file://middleware/auth.go)
- [user.go](file://controller/user.go)
- [twofa.go](file://controller/twofa.go)
- [discord.go](file://controller/discord.go)
- [telegram.go](file://controller/telegram.go)
- [oidc.go](file://controller/oidc.go)
- [user.go](file://model/user.go)
- [token.go](file://model/token.go)
- [twofa.go](file://model/twofa.go)
- [totp.go](file://common/totp.go)
- [api-router.go](file://router/api-router.go)
- [web-router.go](file://router/web-router.go)
- [discord.go](file://setting/system_setting/discord.go)
- [oidc.go](file://setting/system_setting/oidc.go)
</cite>

## 目录
1. [简介](#简介)
2. [双重认证机制](#双重认证机制)
3. [两步验证实现](#两步验证实现)
4. [第三方授权登录](#第三方授权登录)
5. [认证中间件](#认证中间件)
6. [认证失败处理](#认证失败处理)

## 简介
本系统实现了一套完整的用户认证体系，支持基于会话和访问令牌的双重认证方式，同时集成了两步验证（2FA）和多种第三方授权登录功能。系统通过灵活的认证中间件对请求进行权限校验，确保了系统的安全性和可用性。

**Section sources**
- [user.go](file://controller/user.go#L1-L1295)
- [auth.go](file://middleware/auth.go#L1-L322)

## 双重认证机制

### 登录与会话管理
系统实现了基于会话的用户认证流程。用户通过用户名和密码进行登录，服务器验证成功后创建会话并返回用户信息。会话信息存储在服务端，包含用户ID、用户名、角色、状态和用户组等关键信息。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Controller as "Login控制器"
participant Model as "User模型"
participant Session as "会话存储"
Client->>Controller : POST /api/login
Controller->>Model : ValidateAndFill()
Model-->>Controller : 用户验证结果
alt 用户启用2FA
Controller->>Session : 设置pending会话
Session-->>Controller : 会话保存成功
Controller-->>Client : 返回需2FA验证
else 验证通过
Controller->>Session : 创建用户会话
Session-->>Controller : 会话创建成功
Controller->>Client : 返回用户信息
end
```

**Diagram sources**
- [user.go](file://controller/user.go#L30-L95)
- [user.go](file://model/user.go#L500-L517)

### 访问令牌认证
系统支持访问令牌（Access Token）认证方式，为API调用提供无状态的认证机制。用户可以通过生成访问令牌，用于替代传统的会话认证。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Auth as "认证中间件"
participant Model as "User模型"
Client->>Auth : 请求(含Authorization头)
Auth->>Model : ValidateAccessToken()
alt 令牌有效
Model-->>Auth : 返回用户信息
Auth->>Client : 继续处理请求
else 令牌无效
Auth-->>Client : 返回401未授权
end
```

**Diagram sources**
- [auth.go](file://middleware/auth.go#L37-L71)
- [user.go](file://model/user.go#L657-L667)

### 注销流程
用户注销时，系统会清除会话中的所有信息，确保用户身份立即失效。

```mermaid
flowchart TD
Start([开始注销]) --> ClearSession["清除会话数据"]
ClearSession --> SaveSession["保存会话"]
SaveSession --> CheckError{"保存成功?"}
CheckError --> |是| ReturnSuccess["返回成功响应"]
CheckError --> |否| ReturnError["返回错误信息"]
ReturnSuccess --> End([结束])
ReturnError --> End
```

**Diagram sources**
- [user.go](file://controller/user.go#L128-L143)

**Section sources**
- [auth.go](file://middleware/auth.go#L1-L322)
- [user.go](file://controller/user.go#L30-L143)

## 两步验证实现

### TOTP生成与验证
系统采用基于时间的一次性密码（TOTP）算法实现两步验证。用户启用2FA时，系统生成一个密钥，并将其编码为二维码供用户扫描添加到认证器应用中。

```mermaid
classDiagram
class TwoFA {
+int Id
+int UserId
+string Secret
+bool IsEnabled
+int FailedAttempts
+*time.Time LockedUntil
+*time.Time LastUsedAt
+time.Time CreatedAt
+time.Time UpdatedAt
+GetTwoFAByUserId(userId int) *TwoFA
+IsTwoFAEnabled(userId int) bool
+Create() error
+Update() error
+Delete() error
+Enable() error
+ValidateTOTPAndUpdateUsage(code string) (bool, error)
}
class TwoFABackupCode {
+int Id
+int UserId
+string CodeHash
+bool IsUsed
+*time.Time UsedAt
+time.Time CreatedAt
+time.Time DeletedAt
}
class TOTPUtil {
+GenerateTOTPSecret(accountName string) *otp.Key
+ValidateTOTPCode(secret, code string) bool
+GenerateQRCodeData(secret, username string) string
}
TwoFA --> TwoFABackupCode : "1对多"
TOTPUtil --> TwoFA : "使用"
```

**Diagram sources**
- [twofa.go](file://model/twofa.go#L13-L324)
- [totp.go](file://common/totp.go#L1-L151)

### 2FA完整流程
两步验证的实现包括设置、启用、禁用和验证等多个环节，确保了用户账户的安全性。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Controller as "2FA控制器"
participant Model as "2FA模型"
participant TOTP as "TOTP工具"
Client->>Controller : 请求设置2FA
Controller->>Model : GetTwoFAByUserId()
alt 用户已启用2FA
Controller-->>Client : 返回已启用提示
else 未设置
Controller->>TOTP : GenerateTOTPSecret()
TOTP-->>Controller : 返回密钥
Controller->>TOTP : GenerateQRCodeData()
TOTP-->>Controller : 返回二维码数据
Controller->>Model : 创建2FA记录
Model-->>Controller : 创建成功
Controller->>Controller : 生成备用码
Controller->>Client : 返回设置信息
end
```

**Diagram sources**
- [twofa.go](file://controller/twofa.go#L34-L135)

### 备用码机制
为防止用户丢失认证设备，系统提供了备用码机制。用户在设置2FA时会生成一组备用码，可用于在无法访问认证器时进行身份验证。

```mermaid
flowchart TD
Start([生成备用码]) --> GenerateCodes["生成8位随机码"]
GenerateCodes --> FormatCodes["格式化为XXXX-XXXX"]
FormatCodes --> HashCodes["对每个码进行哈希"]
HashCodes --> StoreCodes["存储哈希值到数据库"]
StoreCodes --> ReturnCodes["返回明文码给用户"]
ReturnCodes --> WarnUser["警告用户妥善保管"]
WarnUser --> End([结束])
```

**Diagram sources**
- [totp.go](file://common/totp.go#L48-L61)
- [twofa.go](file://model/twofa.go#L144-L172)

**Section sources**
- [twofa.go](file://controller/twofa.go#L1-L555)
- [twofa.go](file://model/twofa.go#L1-L324)
- [totp.go](file://common/totp.go#L1-L151)

## 第三方授权登录

### Discord集成
系统支持通过Discord账号进行登录和注册。用户点击Discord登录按钮后，会被重定向到Discord的授权页面，授权后返回应用完成登录或注册流程。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Controller as "Discord控制器"
participant OAuth as "Discord OAuth"
participant Model as "User模型"
Client->>Controller : 重定向到Discord OAuth
Controller->>OAuth : 请求授权码
OAuth-->>Client : 重定向回应用
Client->>Controller : 提供授权码
Controller->>OAuth : 交换访问令牌
OAuth-->>Controller : 返回访问令牌
Controller->>OAuth : 获取用户信息
OAuth-->>Controller : 返回用户数据
alt 用户已绑定
Controller->>Model : FillUserByDiscordId()
Model-->>Controller : 返回用户信息
else 新用户
Controller->>Model : 创建新用户
Model-->>Controller : 创建成功
end
Controller->>Controller : setupLogin()
Controller-->>Client : 完成登录
```

**Diagram sources**
- [discord.go](file://controller/discord.go#L102-L179)

### Telegram集成
Telegram登录采用Telegram的WebApp授权机制，通过验证请求参数的签名来确保请求的合法性。

```mermaid
flowchart TD
Start([Telegram登录]) --> GetParams["获取URL参数"]
GetParams --> ValidateSign["验证HMAC签名"]
ValidateSign --> CheckValid{"签名有效?"}
CheckValid --> |否| ReturnError["返回无效请求"]
CheckValid --> |是| GetTelegramId["提取Telegram ID"]
GetTelegramId --> CheckBound["检查是否已绑定"]
CheckBound --> |已绑定| FindUser["查找用户"]
CheckBound --> |未绑定| BindUser["绑定到当前账户"]
FindUser --> CompleteLogin["完成登录"]
BindUser --> UpdateUser["更新用户信息"]
UpdateUser --> Redirect["重定向到个人中心"]
CompleteLogin --> End([结束])
Redirect --> End
ReturnError --> End
```

**Diagram sources**
- [telegram.go](file://controller/telegram.go#L72-L99)

### OIDC集成
系统支持OpenID Connect标准，允许用户通过任何符合OIDC标准的身份提供商进行登录。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Controller as "OIDC控制器"
participant OIDC as "OIDC提供者"
participant Model as "User模型"
Client->>Controller : 重定向到OIDC提供者
Controller->>OIDC : 请求授权
OIDC-->>Client : 重定向回应用
Client->>Controller : 提供授权码
Controller->>OIDC : 交换令牌
OIDC-->>Controller : 返回ID令牌
Controller->>OIDC : 获取用户信息
OIDC-->>Controller : 返回用户数据
alt 用户已绑定
Controller->>Model : FillUserByOidcId()
Model-->>Controller : 返回用户信息
else 新用户
Controller->>Model : 创建新用户
Model-->>Controller : 创建成功
end
Controller->>Controller : setupLogin()
Controller-->>Client : 完成登录
```

**Diagram sources**
- [oidc.go](file://controller/oidc.go#L104-L182)

### 用户绑定流程
已登录用户可以将第三方账户绑定到自己的账号上，实现多方式登录。

```mermaid
flowchart TD
Start([开始绑定]) --> CheckLogin["检查用户登录状态"]
CheckLogin --> IsLoggedIn{"已登录?"}
IsLoggedIn --> |否| RedirectLogin["重定向到登录"]
IsLoggedIn --> |是| GetAuthCode["获取授权码"]
GetAuthCode --> ValidateAuth["验证授权"]
ValidateAuth --> GetUserInfo["获取第三方用户信息"]
GetUserInfo --> CheckBound["检查第三方账号是否已绑定"]
CheckBound --> |已绑定| ReturnError["返回绑定失败"]
CheckBound --> |未绑定| GetCurrentSession["获取当前会话用户"]
GetCurrentSession --> UpdateUser["更新用户绑定信息"]
UpdateUser --> SaveUser["保存用户信息"]
SaveUser --> ReturnSuccess["返回绑定成功"]
ReturnSuccess --> End([结束])
ReturnError --> End
RedirectLogin --> End
```

**Diagram sources**
- [discord.go](file://controller/discord.go#L181-L224)
- [oidc.go](file://controller/oidc.go#L184-L228)

**Section sources**
- [discord.go](file://controller/discord.go#L1-L224)
- [telegram.go](file://controller/telegram.go#L1-L126)
- [oidc.go](file://controller/oidc.go#L1-L229)
- [discord.go](file://setting/system_setting/discord.go#L1-L22)
- [oidc.go](file://setting/system_setting/oidc.go#L1-L26)

## 认证中间件

### 请求头解析
认证中间件负责解析请求头中的认证信息，包括Authorization头和New-Api-User头，确保请求的合法性。

```mermaid
flowchart TD
Start([请求进入]) --> CheckSession["检查会话"]
CheckSession --> HasSession{"存在会话?"}
HasSession --> |是| UseSession["使用会话信息"]
HasSession --> |否| CheckToken["检查访问令牌"]
CheckToken --> HasToken{"存在令牌?"}
HasToken --> |是| ValidateToken["验证令牌"]
HasToken --> |否| ReturnUnauthorized["返回未授权"]
ValidateToken --> IsValid{"令牌有效?"}
IsValid --> |否| ReturnInvalidToken["返回令牌无效"]
IsValid --> |是| UseToken["使用令牌信息"]
UseSession --> CheckUserId["检查New-Api-User"]
UseToken --> CheckUserId
CheckUserId --> MatchUser{"用户ID匹配?"}
MatchUser --> |否| ReturnMismatch["返回用户不匹配"]
MatchUser --> |是| CheckStatus["检查用户状态"]
CheckStatus --> IsActive{"用户启用?"}
IsActive --> |否| ReturnDisabled["返回用户被封禁"]
IsActive --> |是| CheckRole["检查权限等级"]
CheckRole --> HasPermission{"权限足够?"}
HasPermission --> |否| ReturnForbidden["返回权限不足"]
HasPermission --> |是| SetContext["设置上下文"]
SetContext --> Next["继续处理请求"]
Next --> End([结束])
```

**Diagram sources**
- [auth.go](file://middleware/auth.go#L30-L143)

### 权限校验
系统实现了基于角色的权限控制（RBAC），不同角色具有不同的操作权限。

```mermaid
classDiagram
class AuthMiddleware {
+validUserInfo(username string, role int) bool
+authHelper(c *gin.Context, minRole int)
+UserAuth() func(c *gin.Context)
+AdminAuth() func(c *gin.Context)
+RootAuth() func(c *gin.Context)
+TokenAuth() func(c *gin.Context)
}
class Role {
+RoleCommonUser = 1
+RoleAdminUser = 2
+RoleRootUser = 3
}
AuthMiddleware --> Role : "使用"
```

**Diagram sources**
- [auth.go](file://middleware/auth.go#L19-L173)

### 令牌认证
对于API令牌认证，中间件会解析各种来源的令牌密钥，包括标准的Authorization头、WebSocket协议头、查询参数等。

```mermaid
sequenceDiagram
participant Client as "客户端"
participant Middleware as "认证中间件"
participant Model as "Token模型"
Client->>Middleware : 发送请求
Middleware->>Middleware : 检查WebSocket协议
alt 是WebSocket请求
Middleware->>Middleware : 从Sec-WebSocket-Protocol提取密钥
end
Middleware->>Middleware : 检查路径是否为/v1/messages
alt 是Anthropic API
Middleware->>Middleware : 从x-api-key头提取密钥
end
Middleware->>Middleware : 检查是否为Gemini API
alt 是Gemini API
Middleware->>Middleware : 从key查询参数或x-goog-api-key头提取密钥
end
Middleware->>Middleware : 从Authorization头提取密钥
Middleware->>Model : ValidateUserToken()
Model-->>Middleware : 返回令牌信息
alt 令牌有效
Middleware->>Middleware : 检查IP限制
Middleware->>Middleware : 检查用户状态
Middleware->>Middleware : 设置上下文
Middleware-->>Client : 继续处理
else 令牌无效
Middleware-->>Client : 返回错误
end
```

**Diagram sources**
- [auth.go](file://middleware/auth.go#L179-L289)

**Section sources**
- [auth.go](file://middleware/auth.go#L1-L322)

## 认证失败处理

### 常见失败场景
系统对各种认证失败场景进行了详细的处理和反馈，帮助用户和开发者快速定位问题。

| 失败场景 | 错误代码 | 错误信息 | 处理建议 |
|---------|---------|---------|---------|
| 未提供访问令牌 | 401 | 无权进行此操作，未登录且未提供 access token | 检查是否提供了有效的访问令牌 |
| 访问令牌无效 | 401 | 无权进行此操作，access token 无效 | 生成新的访问令牌并重试 |
| New-Api-User缺失 | 401 | 无权进行此操作，未提供 New-Api-User | 在请求头中添加New-Api-User字段 |
| 用户ID不匹配 | 401 | 无权进行此操作，New-Api-User 与登录用户不匹配 | 确保New-Api-User与当前登录用户一致 |
| 用户被封禁 | 200 | 用户已被封禁 | 联系管理员解封账户 |
| 权限不足 | 200 | 无权进行此操作，权限不足 | 使用具有足够权限的账户登录 |
| 2FA验证码错误 | 200 | 验证码或备用码错误，请重试 | 检查验证码是否正确，或使用备用码 |
| 账户被锁定 | 200 | 账户已被锁定，请在XX后重试 | 等待锁定时间结束后重试 |
| IP不在允许列表 | 403 | 您的 IP 不在令牌允许访问的列表中 | 将当前IP添加到令牌的IP限制列表中 |

**Section sources**
- [auth.go](file://middleware/auth.go#L1-L322)
- [twofa.go](file://controller/twofa.go#L1-L555)