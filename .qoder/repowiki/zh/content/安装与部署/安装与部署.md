# 安装与部署

<cite>
**本文档引用的文件**  
- [Dockerfile](file://Dockerfile)
- [docker-compose.yml](file://docker-compose.yml)
- [.env.example](file://.env.example)
- [main.go](file://main.go)
- [common/env.go](file://common/env.go)
- [common/database.go](file://common/database.go)
- [common/redis.go](file://common/redis.go)
- [docs/installation/BT.md](file://docs/installation/BT.md)
- [bin/migration_v0.2-v0.3.sql](file://bin/migration_v0.2-v0.3.sql)
- [bin/migration_v0.3-v0.4.sql](file://bin/migration_v0.3-v0.4.sql)
- [setting/config/config.go](file://setting/config/config.go)
- [constant/env.go](file://constant/env.go)
- [common/init.go](file://common/init.go)
</cite>

## 目录
1. [简介](#简介)
2. [环境准备](#环境准备)
3. [Docker 部署](#docker-部署)
4. [Docker Compose 部署](#docker-compose-部署)
5. [宝塔面板部署](#宝塔面板部署)
6. [数据库配置](#数据库配置)
7. [Redis 配置](#redis-配置)
8. [多机部署注意事项](#多机部署注意事项)
9. [故障排除指南](#故障排除指南)
10. [性能优化建议](#性能优化建议)
11. [生产环境最佳实践](#生产环境最佳实践)

## 简介
本文档详细说明了 new-api 项目的完整安装与部署流程。涵盖了 Docker、Docker Compose 和宝塔面板三种主要部署方式，以及数据库（SQLite、MySQL、PostgreSQL）、Redis 配置和多机部署的注意事项。同时提供详细的故障排除指南、性能优化建议和生产环境部署的最佳实践。

## 环境准备
在开始部署之前，请确保您的系统满足以下要求：

- **操作系统**: Linux (推荐 Ubuntu 20.04/22.04, CentOS 7/8)
- **Docker**: 版本 20.10 或更高
- **Docker Compose**: 版本 1.29 或更高
- **内存**: 至少 2GB RAM
- **磁盘空间**: 至少 5GB 可用空间
- **网络**: 稳定的互联网连接

**安装 Docker 和 Docker Compose**

```bash
# 安装 Docker
curl -fsSL https://get.docker.com -o get-docker.sh
sudo sh get-docker.sh

# 安装 Docker Compose
sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
sudo chmod +x /usr/local/bin/docker-compose
```

**验证安装**

```bash
docker --version
docker-compose --version
```

**Section sources**
- [Dockerfile](file://Dockerfile)
- [docker-compose.yml](file://docker-compose.yml)

## Docker 部署
使用 Docker 可以快速部署 new-api 服务。以下是详细的部署步骤：

**1. 拉取镜像**

```bash
docker pull calciumion/new-api:latest
```

**2. 创建必要的目录**

```bash
mkdir -p /opt/new-api/data
mkdir -p /opt/new-api/logs
```

**3. 运行容器**

```bash
docker run -d \
  --name new-api \
  -p 3000:3000 \
  -v /opt/new-api/data:/data \
  -v /opt/new-api/logs:/app/logs \
  -e SQL_DSN="postgresql://root:your_password@postgres_host:5432/new-api" \
  -e REDIS_CONN_STRING="redis://your_redis_host:6379" \
  -e SESSION_SECRET="your_random_secret_string" \
  -e TZ="Asia/Shanghai" \
  --restart always \
  calciumion/new-api:latest
```

**4. 验证服务状态**

```bash
docker logs new-api
docker ps | grep new-api
```

**环境变量说明**

- `SQL_DSN`: 数据库连接字符串
- `REDIS_CONN_STRING`: Redis 连接字符串
- `SESSION_SECRET`: 会话密钥，多机部署时必须设置且保持一致
- `TZ`: 时区设置
- `ERROR_LOG_ENABLED`: 是否启用错误日志记录
- `BATCH_UPDATE_ENABLED`: 是否启用批量更新

**Section sources**
- [Dockerfile](file://Dockerfile)
- [docker-compose.yml](file://docker-compose.yml)
- [.env.example](file://.env.example)

## Docker Compose 部署
Docker Compose 提供了一种更简便的方式来管理多个容器服务。以下是完整的部署流程：

**1. 创建项目目录**

```bash
mkdir -p /opt/new-api
cd /opt/new-api
```

**2. 创建 docker-compose.yml 文件**

```yaml
# New-API Docker Compose Configuration
# 
# Quick Start:
#   1. docker-compose up -d
#   2. Access at http://localhost:3000
#
# Using MySQL instead of PostgreSQL:
#   1. Comment out the postgres service and SQL_DSN line 15
#   2. Uncomment the mysql service and SQL_DSN line 16
#   3. Uncomment mysql in depends_on (line 28)
#   4. Uncomment mysql_data in volumes section (line 64)
#
# ⚠️  IMPORTANT: Change all default passwords before deploying to production!

version: '3.4' # For compatibility with older Docker versions

services:
  new-api:
    image: calciumion/new-api:latest
    container_name: new-api
    restart: always
    command: --log-dir /app/logs
    ports:
      - "3000:3000"
    volumes:
      - ./data:/data
      - ./logs:/app/logs
    environment:
      - SQL_DSN=postgresql://root:your_secure_password@postgres:5432/new-api
      - REDIS_CONN_STRING=redis://redis
      - TZ=Asia/Shanghai
      - ERROR_LOG_ENABLED=true
      - BATCH_UPDATE_ENABLED=true
      - SESSION_SECRET=your_random_string_here
    depends_on:
      - redis
      - postgres
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O - http://localhost:3000/api/status | grep -o '\"success\":\\s*true' || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:latest
    container_name: redis
    restart: always

  postgres:
    image: postgres:15
    container_name: postgres
    restart: always
    environment:
      POSTGRES_USER: root
      POSTGRES_PASSWORD: your_secure_password
      POSTGRES_DB: new-api
    volumes:
      - pg_data:/var/lib/postgresql/data

volumes:
  pg_data:
```

**3. 启动服务**

```bash
docker-compose up -d
```

**4. 使用 MySQL 替代 PostgreSQL**

如果需要使用 MySQL，请修改 docker-compose.yml 文件：

```yaml
# 注释掉 postgres 服务，取消注释 mysql 服务
  mysql:
    image: mysql:8.2
    container_name: mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: your_secure_password
      MYSQL_DATABASE: new-api
    volumes:
      - mysql_data:/var/lib/mysql

# 在 new-api 服务中，注释掉 postgresql DSN，取消注释 mysql DSN
      - SQL_DSN=root:your_secure_password@tcp(mysql:3306)/new-api

# 在 depends_on 中，注释掉 postgres，取消注释 mysql
      - mysql

# 在 volumes 部分，取消注释 mysql_data
volumes:
  mysql_data:
```

**5. 验证部署**

```bash
docker-compose ps
docker-compose logs new-api
```

**Section sources**
- [docker-compose.yml](file://docker-compose.yml)
- [.env.example](file://.env.example)

## 宝塔面板部署
宝塔面板提供了一个图形化界面来管理服务器。以下是使用宝塔面板部署 new-api 的步骤：

**1. 安装宝塔面板**

```bash
# Ubuntu/Debian
wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh && sudo bash install.sh

# CentOS
wget -O install.sh https://download.bt.cn/install/install_6.0.sh && bash install.sh
```

**2. 登录宝塔面板**
访问 `http://your_server_ip:8888`，按照提示完成初始化设置。

**3. 安装 Docker 管理器**
在宝塔面板中，进入"软件商店"，搜索并安装"Docker 管理器"。

**4. 创建容器**
使用 Docker 管理器创建 new-api 容器：

- **镜像名称**: `calciumion/new-api:latest`
- **容器名称**: `new-api`
- **端口映射**: `3000:3000`
- **卷映射**: 
  - `/opt/new-api/data` → `/data`
  - `/opt/new-api/logs` → `/app/logs`
- **环境变量**:
  - `SQL_DSN`: `postgresql://root:your_password@postgres_host:5432/new-api`
  - `REDIS_CONN_STRING`: `redis://your_redis_host:6379`
  - `SESSION_SECRET`: `your_random_secret_string`
  - `TZ`: `Asia/Shanghai`

**5. 配置反向代理（可选）**
如果需要通过域名访问，可以在宝塔面板中创建网站并配置反向代理：

- **目标 URL**: `http://127.0.0.1:3000`
- **启用 SSL**: 是

**注意事项**
- 宝塔面板中的"密钥"指的是环境变量 `SESSION_SECRET`
- 确保防火墙允许 3000 端口的流量
- 定期备份 `/opt/new-api/data` 目录

**Section sources**
- [docs/installation/BT.md](file://docs/installation/BT.md)
- [docker-compose.yml](file://docker-compose.yml)

## 数据库配置
new-api 支持多种数据库后端，包括 SQLite、MySQL 和 PostgreSQL。以下是各种数据库的配置方法。

**1. SQLite 配置**
SQLite 是最简单的选择，适合小型部署。

```bash
# 在 .env 文件中设置
SQLITE_PATH=/data/one-api.db?_busy_timeout=30000
```

或通过环境变量：

```bash
-e SQLITE_PATH=/data/one-api.db?_busy_timeout=30000
```

**2. MySQL 配置**
MySQL 适合中大型部署，需要单独的 MySQL 服务。

```bash
# 数据库连接字符串格式
SQL_DSN=root:password@tcp(mysql_host:3306)/new-api?charset=utf8mb4&parseTime=True&loc=Local

# 在 docker-compose.yml 中
- SQL_DSN=root:your_password@tcp(mysql:3306)/new-api
```

**3. PostgreSQL 配置**
PostgreSQL 提供了更好的性能和可靠性。

```bash
# 数据库连接字符串格式
SQL_DSN=postgresql://user:password@host:5432/database_name?sslmode=disable

# 在 docker-compose.yml 中
- SQL_DSN=postgresql://root:your_password@postgres:5432/new-api
```

**4. 数据库迁移**
系统会自动处理数据库迁移。如果需要手动执行迁移脚本：

```sql
-- 从 v0.2 到 v0.3 的迁移
UPDATE users
SET quota = quota + (
    SELECT SUM(remain_quota)
    FROM tokens
    WHERE tokens.user_id = users.id
);

-- 从 v0.3 到 v0.4 的迁移
INSERT INTO abilities (`group`, model, channel_id, enabled)
SELECT c.`group`, m.model, c.id, 1
FROM channels c
CROSS JOIN (
    SELECT 'gpt-3.5-turbo' AS model UNION ALL
    SELECT 'gpt-3.5-turbo-0301' AS model UNION ALL
    SELECT 'gpt-4' AS model UNION ALL
    SELECT 'gpt-4-0314' AS model
) AS m
WHERE c.status = 1
  AND NOT EXISTS (
    SELECT 1
    FROM abilities a
    WHERE a.`group` = c.`group`
      AND a.model = m.model
      AND a.channel_id = c.id
);
```

**5. 数据库连接池配置**

```bash
# 最大空闲连接数
SQL_MAX_IDLE_CONNS=100

# 最大打开连接数
SQL_MAX_OPEN_CONNS=1000

# 连接最大生命周期（秒）
SQL_MAX_LIFETIME=60
```

**Section sources**
- [common/database.go](file://common/database.go)
- [bin/migration_v0.2-v0.3.sql](file://bin/migration_v0.2-v0.3.sql)
- [bin/migration_v0.3-v0.4.sql](file://bin/migration_v0.3-v0.4.sql)
- [.env.example](file://.env.example)

## Redis 配置
Redis 用于缓存和会话管理，可以显著提高系统性能。

**1. Redis 连接配置**

```bash
# Redis 连接字符串
REDIS_CONN_STRING=redis://user:password@host:6379/0

# 在 docker-compose.yml 中
- REDIS_CONN_STRING=redis://redis
```

**2. Redis 连接池配置**

```bash
# Redis 连接池大小
REDIS_POOL_SIZE=10
```

**3. 缓存同步频率**

```bash
# 缓存同步频率（秒）
SYNC_FREQUENCY=60
```

**4. 内存缓存启用**

```bash
# 启用内存缓存
MEMORY_CACHE_ENABLED=true
```

**5. Redis 初始化**
在 `common/redis.go` 中，系统会自动处理 Redis 的初始化和连接测试：

```go
func InitRedisClient() (err error) {
	if os.Getenv("REDIS_CONN_STRING") == "" {
		RedisEnabled = false
		SysLog("REDIS_CONN_STRING not set, Redis is not enabled")
		return nil
	}
	
	opt, err := redis.ParseURL(os.Getenv("REDIS_CONN_STRING"))
	if err != nil {
		FatalLog("failed to parse Redis connection string: " + err.Error())
	}
	
	RDB = redis.NewClient(opt)
	
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	
	_, err = RDB.Ping(ctx).Result()
	if err != nil {
		FatalLog("Redis ping test failed: " + err.Error())
	}
	
	return err
}
```

**Section sources**
- [common/redis.go](file://common/redis.go)
- [docker-compose.yml](file://docker-compose.yml)
- [.env.example](file://.env.example)

## 多机部署注意事项
在多机部署场景下，需要注意以下几点以确保系统稳定运行。

**1. 会话密钥一致性**
所有节点必须使用相同的 `SESSION_SECRET`，否则会导致会话无法共享。

```bash
# 所有节点的 .env 文件中必须设置相同的值
SESSION_SECRET=your_random_string_here
```

**2. 数据库共享**
所有节点必须连接到同一个数据库实例，确保数据一致性。

**3. Redis 共享**
使用同一个 Redis 实例或集群，用于缓存和会话共享。

**4. 负载均衡**
建议使用 Nginx 或 HAProxy 进行负载均衡：

```nginx
upstream newapi_backend {
    server node1_ip:3000;
    server node2_ip:3000;
    server node3_ip:3000;
}

server {
    listen 80;
    server_name your_domain.com;
    
    location / {
        proxy_pass http://newapi_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
}
```

**5. 主节点设置**
通过 `NODE_TYPE` 环境变量指定主节点：

```bash
# 主节点
NODE_TYPE=master

# 从节点
NODE_TYPE=slave
```

**6. 批量更新配置**
在多机环境中，批量更新需要协调：

```bash
# 批量更新间隔（秒）
BATCH_UPDATE_INTERVAL=5

# 启用批量更新
BATCH_UPDATE_ENABLED=true
```

**Section sources**
- [main.go](file://main.go)
- [common/init.go](file://common/init.go)
- [docker-compose.yml](file://docker-compose.yml)

## 故障排除指南
本节提供常见问题的解决方案。

**1. 端口冲突**
如果 3000 端口已被占用：

```bash
# 检查端口占用
netstat -tlnp | grep 3000

# 更改端口
docker run -d -p 3001:3000 ... # 使用 3001 端口
```

或在 docker-compose.yml 中修改：

```yaml
ports:
  - "3001:3000"
```

**2. 权限错误**
如果遇到文件权限问题：

```bash
# 确保数据目录有正确权限
sudo chown -R 1000:1000 /opt/new-api/data
sudo chown -R 1000:1000 /opt/new-api/logs

# 或使用 root 用户运行
docker run -u root ...
```

**3. 数据库连接失败**
检查数据库服务是否正常运行：

```bash
# 测试 PostgreSQL 连接
psql -h postgres_host -U root -d new-api

# 测试 MySQL 连接
mysql -h mysql_host -u root -p
```

确保防火墙允许数据库端口的流量。

**4. Redis 连接失败**
检查 Redis 服务状态：

```bash
# 测试 Redis 连接
redis-cli -h redis_host ping

# 检查 Redis 是否需要密码
redis-cli -h redis_host -a your_password ping
```

**5. 环境变量未生效**
确保环境变量正确设置：

```bash
# 检查容器内的环境变量
docker exec new-api printenv | grep SQL_DSN

# 或在启动时明确指定
docker run -e SQL_DSN="your_connection_string" ...
```

**6. 会话密钥警告**
如果看到 SESSION_SECRET 警告：

```bash
# 必须设置一个随机字符串
-e SESSION_SECRET=your_random_string_here
```

默认值 "random_string" 不能用于生产环境。

**7. 健康检查失败**
如果容器健康检查失败：

```bash
# 手动测试 API 状态
curl http://localhost:3000/api/status

# 检查日志
docker logs new-api
```

**Section sources**
- [main.go](file://main.go)
- [common/init.go](file://common/init.go)
- [docker-compose.yml](file://docker-compose.yml)

## 性能优化建议
为了获得最佳性能，请考虑以下优化建议。

**1. 数据库优化**

```bash
# 增加连接池大小
SQL_MAX_IDLE_CONNS=200
SQL_MAX_OPEN_CONNS=2000

# 优化连接生命周期
SQL_MAX_LIFETIME=300
```

**2. Redis 优化**

```bash
# 增加 Redis 连接池
REDIS_POOL_SIZE=20

# 调整缓存同步频率
SYNC_FREQUENCY=30
```

**3. 批量更新优化**

```bash
# 减少批量更新间隔
BATCH_UPDATE_INTERVAL=2

# 确保启用批量更新
BATCH_UPDATE_ENABLED=true
```

**4. 请求超时设置**

```bash
# 设置合理的请求超时
RELAY_TIMEOUT=120

# 流模式超时
STREAMING_TIMEOUT=300
```

**5. 日志配置**

```bash
# 启用错误日志记录
ERROR_LOG_ENABLED=true

# 优化日志目录
LOG_DIR=/data/logs
```

**6. 系统资源**
- 为容器分配足够的内存（建议 4GB 或更多）
- 使用 SSD 存储以提高 I/O 性能
- 确保网络带宽充足

**Section sources**
- [common/init.go](file://common/init.go)
- [.env.example](file://.env.example)

## 生产环境最佳实践
在生产环境中部署时，请遵循以下最佳实践。

**1. 安全配置**

```bash
# 使用强密码
POSTGRES_PASSWORD=your_strong_password
MYSQL_ROOT_PASSWORD=your_strong_password

# 设置随机会话密钥
SESSION_SECRET=$(openssl rand -base64 32)

# 启用 HTTPS
# 配置反向代理使用 SSL 证书
```

**2. 备份策略**

```bash
# 定期备份数据目录
tar -czf backup-$(date +%Y%m%d).tar.gz /opt/new-api/data

# 自动化备份脚本
0 2 * * * tar -czf /backup/newapi-$(date +\%Y\%m\%d).tar.gz /opt/new-api/data
```

**3. 监控和告警**

```bash
# 启用 pprof 性能分析
ENABLE_PPROF=true

# 配置健康检查
healthcheck:
  test: ["CMD-SHELL", "wget -q -O - http://localhost:3000/api/status | grep -o '\"success\":\\s*true' || exit 1"]
```

**4. 高可用性**

```bash
# 多节点部署
# 使用负载均衡器分发流量

# 数据库主从复制
# 配置 PostgreSQL 或 MySQL 主从

# Redis 集群
# 使用 Redis Sentinel 或 Cluster
```

**5. 环境隔离**

```bash
# 为不同环境使用不同的配置
# 开发环境
ENV=development

# 生产环境
ENV=production
```

**6. 版本管理**

```bash
# 使用特定版本的镜像
image: calciumion/new-api:v1.2.0

# 避免使用 latest 标签
# 便于回滚和版本控制
```

**7. 访问控制**

```bash
# 限制数据库访问
# 只允许应用服务器访问数据库端口

# 使用防火墙规则
# 限制管理接口的访问 IP
```

**Section sources**
- [main.go](file://main.go)
- [docker-compose.yml](file://docker-compose.yml)
- [.env.example](file://.env.example)